# Node.js 혼자 깨부수기 1일차

## 1. 노드시작하기

#### 1.1 핵심개념

>  Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 JS 런타임입니다.
>  Node.js는 **이벤트기반**, **논블로킹 I/O모델**을 사용해 가볍고 효율적입니다.
>  Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.



---

###### 1.1.1 서버

> 노드는 서버 앱을 실행하는 데 제일 많이 사용됩니다.

​	**서버**란 네트워크를 통해 클라이언트에 정보나 서비스를 제공하는 컴퓨터 또는 프로그램.
​	**클라이언트**란 요청을 보내는 주체.

​	노드는 JS 앱이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할을 수행할 수 있다.

- 왜 다른 언어말고 굳이 노드를 사용해 서버를 만듬??

  

---

###### 1.1.2 JS 런타임

> 노드는 자바스크립트 런타임.	

**런타임**이란, 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻함. 
따라서 노드는 JS 프로그램을 컴퓨터에서 실행할 수 있게 해줌.

> > 기존에는 JS 프로그램을 인터넷 브라우저 위에서만 실행할 수 있었다(브라우저도 JS 런타임). 
> > 브라우저 외의 환경에서 JS를 실행하기 위한 시도가 있었으나, JS 실행 속도 문제 때문에 전부 호응을 얻지 못함.
> >
> > But, 2008년 구글이 V8엔진을 사용하여 크롬을 출시, 당시 V8엔진은 다른 JS엔진 보다 매우 빨랐고, 오픈소스로 코드도 공개됨!!! 
> > 속도 문제가 해결되자 라이언 달이 2009년에 V8엔진 기반의 노드 프로젝트를 시작.



<img src="C:\Users\SinJ\AppData\Roaming\Typora\typora-user-images\image-20191211133833682.png" alt="image-20191211133833682" style="zoom:80%;" />

노드는 **V8**과 더불어 **libuv**라는 라이브러리를 사용. (V8과 libuv는 C와 C++로 구현되어 있고 노드가 알아서 연결해줌.)

**libuv** 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현하고 있다.



---

###### 1.1.3 이벤트 기반

> **이벤트 기반(event-dirven)**이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 
> ex) 클릭, 네트워크 요청

<img src="C:\Users\SinJ\AppData\Roaming\Typora\typora-user-images\image-20191211185616253.png" alt="image-20191211185616253" style="zoom:80%;" />

이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 한다.
이것을 **이벤트 리스너**에 **콜백 함수**를 등록한다고 표현한다.

**노드**도 **이벤트 기반**이므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다.
발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 다음 이벤트 발생까지 대기한다. 

이벤트 기반 모델에서는 **이벤트 루프**라는 개념이 등장한다.
여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다.



노드는 자바스크립트 코드에서 맨 위부터 한 줄씩 실행한다. 함수 호출 부분을 발견했다면 호출한 함수를 호출 **스택**에 넣는다. 따라서 실행은 호출된 순서와는 반대로 실행된다.

```js
function first(){
	second();
	console.log('첫 번째');
}
function second(){
	third();
	console.log('두 번째');
}
function third(){
	console.log('세 번째');
}

first(); //호출
```

<img src="C:\Users\SinJ\AppData\Roaming\Typora\typora-user-images\image-20191211190917985.png" alt="image-20191211190917985" style="zoom:80%;" />

> > main 함수는 처음 실행 시의 **`전역 컨텍스트`**를 의미한다. 
> > **`컨텍스트`**란 함수가 호출 되었을 때 생성되는 환경을 의미한다.
> > JS 실행 시 기본적으로 전역 컨텍스트 안에서 돌아간다고 생각하는 게 좋다.
> > 함수의 실행이 완료되면 호출 스택에서 지워진다. 
> > third -> second -> first -> main 순으로 지워지고, main 함수까지 실행이 모두 완료되면 호출스택은 비어있게 된다.

```js
##출력 결과
세 번째
두 번째
첫 번째
```



이번에는 setTimeout을 사용해보자.

```js
function run(){
	console.log('3초 후 실행');
}
console.log('시작');
setTimeout(run, 3000);
console.log('끝');
```

```js
##출력 결과
시작
끝
3초 후 실행
```

콘솔 결과를 쉽게 예측할 수 있지만, 호출 스택으로는 설명하기 힘들다.
이를 파악하기 위해서는 **`이벤트 루프`**, **`태스크 큐`**, **`백그라운드`**에 대해 알아야 한다.

- **이벤트 루프** : 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할.
  노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하기에 루프라고 불린다.
- **태스크 큐** : 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간.
  콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고도 부름.
- **백그라운드** : 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳.

> > main -> setTimeout 순으로 호출 스택에 들어 감.
> > setTimeout이 먼저 실행 됨. 
> > setTimeout이 실행 되면 타이머와 함께 run 콜백을 백그라운드로 보내고 스택에서 빠짐.
> > 백그라운드에서 3초를 센 후 run 함수를 태스크 큐로 보냄.
> > 이벤트 루프는 호출 스택이 비어있으면 태스크 큐에서 함수를 하나씩 가져와 호출 스택에 넣고 실행.
> > 따라서 main까지 실행이 완료되어 호출 스택이 비면, run 콜백은 태스크 큐에서 호출 스택으로 옮겨지고 실행된다.
> > 이벤트 루프는 태스크 큐에 콜백 함수가 들어올 때까지 계속 대기하게 된다.
> >
> > 이벤트 루프는 호출 스택이 비어 있을 때만 태스크 큐에 있는 함수를 가져오기 때문에,
> > 만약, 호출 스택에 함수들이 너무 많이 차 있으면 3초가 지난 후에도 run 함수가 실행이 안될 수도 있다.



---

###### 1.1.4 논블로킹 I/O

> **`논블로킹`**이란 이전 작업이 완료될 때 까지 멈추지 않고 다음 작업을 수행함을 뜻한다.

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효율적으로 처리할 수 있다.
오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식이다. 

하지만, 싱글 스레드 때문에 JS의 모든 코드가 이 방식으로 시간적 이득을 볼 수 있는 건 아니고, I/O 작업이 주로 시간적 이득을 많이 본다.

> 노드는 I/O작업을 할 때 논블로킹 방식으로 동작한다.

setTimeout(콜백, 0)은 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나이다.
<u>하지만, 노드에서는 setTimeout(콜백, 0) 대신 다른 방식을 주로 사용한다.</u>

> setTimeout(콜백, 0)
> ms를 0으로 설정한다고 해서 바로 실행되는 것이 아니다. 
> 기본적인 지연 시간이 있다. HTML5 브라우저는 4ms, 노드에서는 1ms



---

###### 1.1.5 싱글 스레드

> 노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다.

JS와 노드에서 논블로킹이 중요한 이유는 싱글 스레드이기 때문이다. 한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다.

> > 꼭 멀티 스레드가 싱글 스레드 보다 좋은건 아니다. 자원의 낭비가 생길 수 있기 때문이다.
> > 싱글 스레드 - 블로킹 모델 / 싱글 스레드 - 논블로킹 모델 (노드) / 멀티 스레드 - 블로킹 모델
> > 의 비교는 책 30P 참고...

<img src="C:\Users\SinJ\AppData\Roaming\Typora\typora-user-images\image-20191212091241787.png" alt="image-20191212091241787" style="zoom:80%;" />

- **프로세스** : 운영체제에서 할당하는 작업의 단위. 노드나 브라우저 같은 프로그램은 개별적인 프로세서이다.
  프로세스 간에는 메모리 등의 자원을 공유하지 않습니다.
- **스레드** : 프로세스 내에서 실행되는 흐름의 단위. 하나의 프로세스는 스레드를 여러개 가질 수 있다.
  스레드들은 부모 프로세스의 자원을 공유해서 같은 메모리에 접근할 수 있다.

보통 스레드를 일손이라 표현한다. 노드 프로세스는 일손이 하나이기에 요청이 많으면 한 번에 하나의 요청을 처리한다. 블로킹이 심하게 일어나지만 않으면 하나로도 충분하다.

> > 사실 노드 프로세스도 내부적으로 여러 개의 스레드를 갖고 있지만, 우리가 직접 제어할 수 있는 스레드는 하나이기에 그냥 싱글 스레드라고 한다.

노드는 스레드를 늘리기 보단 멀티 프로세싱 방식을 체택했다.
JS 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다.



---

#### 1.2 서버로서의 노드

> 노드 서버의 장단점은, 논블로킹 모델의 장단점과 크게 다르지 않다.
> 장점 : 멀티 스레드 보다는 컴퓨터 자원을 적게 사용한다.
> 단점 : CPU 코어를 하나 밖에 사용하지 못한다.

- 노드 서버는 I/O가 많은 작업에 적합하다. 

  > 노드는 libuv 라이브러리를 사용하여 I/O 작업을 논블로킹 방식으로 처리해준다.

- CPU 부하가 큰 작업에는 적합하지 않다.

  > CPU 연산량이 많으면 블로킹이 발생해 스레드 하나가 감당하기 어렵다.

- 노드는 싱글 스레드라 쉽게 입문 가능.

  > 대신, 하나뿐인 스레드가 에러로 인해 멈추지 않도록 관리해줘야한다.
  > 에러를 제대로 처리하지 못하면 서버 전체가 멈추기 때문이다.

- 웹 서버가 내장되어 있어 입문자가 쉽게 접근 가능.

  > 노드 이외의 서버를 개발하다 보면 Apache, nginx, IIS 처럼 별도의 웹 서버를 설치해야 하거>나,
  > Tomcat 같은 웹 애플리케이션 서버(WAS)를 추가로 설치하는 경우도 있다(이때는 WAS 사용법도 익혀야 함).
  > 노드는 내장 웹 서버를 사용하면 된다(근데 서버 규모가 커지면 결국 웹 서버를 노드 서버와 연결해야 함).  

- 가장 큰 장점은 언어로 JS를 사용한다는 것!!

  > 브라우저도 JS를 사용하므로 서버까지 노드를 사용하면 하나의 언어로 웹 사이트를 개발할 수 있다.
  > 때문에 개발 생산성이 획기적으로 높아졌고, 생산성이 중요한 기업이 노드를 채택한 이유가 된다.
  >
  > Go처럼 비동기에 강점을 보이거나, nginx처럼 정적 파일제공, 로드 밸런싱에 특화된 서버에 비해서는 속도가 느리지만, 생산성으로 어느정도 커버 가능.

- JSON은 덤

  >요즘은 XML대신 JSON으로 데이터를 주고 받는데, JSON이 마침 JS 형식이내??

  

| 장점                                | 단점                                        |
| ----------------------------------- | ------------------------------------------- |
| 멀티 스레드에 비해 자원을 적게 사용 | 싱글 스레드라 CPU 코어 하나만 사용          |
| I/O 작업이 많은 서버로 적합         | CPU 작업이 많은 서버로는 부적합             |
| 멀티 스레드 보다 쉬움               | 하나뿐인 스레드가 멈추지 않도록 관리해야 함 |
| 웹 서버가 내장됨                    | 서버 큐모가 커지면 관리가 어려움            |
| JS 사용                             | 어중간한 성능                               |
| JSON 형식과 호환이 쉬움             |                                             |

따라서, 노드는 **<u>개수는 많지만 크기가 작은 데이터를 실시간으로 주고 받는 데 적합</u>**하다.
네트워크, DB, 디스크 작업 같은 I/O에 특화 되어있기 때문이다.
실시간 채팅, 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다. 

반면 영상 처리, 대규모 데이터 처리 같이 **<u>CPU를 많이 사용하는 작업에는 권장하지 않음</u>**.
노드보다 더 적합한 서버들이 많다. **<u>근데 요즘은 노드로 CPU를 많이 잡아먹는 작업을 처리하는 서비스도 나왔다.(ex. AWS Lambda, Google Cloud Function).</u>** 

웹사이트의 경우, 노드가 동적 콘텐츠를 제공하는 데 뚜렷한 장점이 있는건 아님.
근데 부적합하다는 것도 아님. 템플릿 엔진(Pug, EJS)을 통해 다른 언어와 비슷하게 콘텐츠를 제공할 수 있음.

안정성과 보안성 측면에서도 충분히 검증됨(NASA, AirBnB, Uber, Netflix, Paypal, ebay 등 노드를 씀).



---

#### 1.3 서버 외의 노드

> 노드는 JS 런타임이기 때문에 용도가 서버에만 한정된 것이 아니다.
> 서용 범위가 점점 늘어나 웹, 모바일, 데스크톱 앱 개발에도 사용된다.

노드 기반으로 돌아가는 대표적인 웹 프레임워크

- Angular : 구글 진영, 프론트앤드 앱

- React : 페북 진영

- Electron : 데스크톱 개발 도구, Atom, Slack, Discord, VS Code 등이 Electron으로 개발 됨

  

---

#### 1.4 개발 환경 설치

###### 1.4.1 Node.js 홈피가서 받아

Node.js command prompt 열기

```
#터미널에서 버전 확인
$ node -v
$ npm -v
```



###### 1.4.2 npm 버전 업데이트

Node.js command prompt 열기

```
#터미널
$ npm install -g npm
```



###### 1.4.3 VS Code 설치

파워코드 커스텀 gif 설정 링크 : https://boheeee.tistory.com/15







# 끝.